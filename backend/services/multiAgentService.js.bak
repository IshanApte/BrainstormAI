const { ChatOpenAI } = require('@langchain/openai');
const { HumanMessage, AIMessage, SystemMessage } = require('langchain/schema');
const StormAgent = require('./agents/StormAgent');
const SageAgent = require('./agents/SageAgent');

class MultiAgentService {
  constructor() {
    this.agents = {
      storm: new StormAgent(),
      sage: new SageAgent()
    };
    
    // Model for note generation (keeping this separate)
    this.noteGenerationModel = new ChatOpenAI({
      openAIApiKey: process.env.OPENAI_API_KEY,
      modelName: 'gpt-3.5-turbo',
      temperature: 0.3,
    });
  }
  getConversationStage(conversationHistory) {
    const messageCount = conversationHistory.length;
    
    if (messageCount <= 3) {
      return 'early'; // Gathering context
    } else if (messageCount <= 6) {
      return 'mid'; // Building ideas
    } else {
      return 'deep'; // Comprehensive analysis
    }
  }


  async generateResponse(userMessage, conversationHistory = []) {
    try {
      // Determine which agents should participate
      const participatingAgents = [];
      
      for (const [name, agent] of Object.entries(this.agents)) {
        if (agent.shouldParticipate(userMessage, conversationHistory)) {
          participatingAgents.push({ name, agent });
        }
      }

      // Always ensure Storm participates (as the primary host)
      if (!participatingAgents.find(a => a.name === 'storm')) {
        participatingAgents.unshift({ name: 'storm', agent: this.agents.storm });
      }

      console.log(`Participating agents: ${participatingAgents.map(a => a.name).join(', ')}`);

      // Generate responses from all participating agents
      const agentResponses = await Promise.all(
        participatingAgents.map(async ({ name, agent }) => {
          const response = await agent.generateResponse(userMessage, conversationHistory);
          return response;
        })
      );

      // Format the multi-agent response
      return {
        isMultiAgent: agentResponses.length > 1,
        agents: agentResponses,
        // For backward compatibility, primary response is Storm's
        response: agentResponses.find(r => r.name === 'Storm')?.content || agentResponses[0].content
      };

    } catch (error) {
      console.error('Error in multi-agent response generation:', error);
      // Fallback to Storm only
      try {
        const stormResponse = await this.agents.storm.generateResponse(userMessage, conversationHistory);
        return {
          isMultiAgent: false,
          agents: [stormResponse],
          response: stormResponse.content
        };
      } catch (fallbackError) {
        console.error('Fallback error:', fallbackError);
        throw new Error('Failed to generate response from any agent');
      }
    }
  }

  async generateNotes(conversationHistory) {
    try {
      const conversationText = conversationHistory
        .map(msg => {
          if (msg.role === 'user') {
            return `User: ${msg.content}`;
          } else if (msg.agents) {
            // Handle multi-agent messages
            return msg.agents.map(agent => `${agent.name}: ${agent.content}`).join('\n');
          } else {
            return `Assistant: ${msg.content}`;
          }
        })
        .join('\n');

      const notePrompt = `Based on the following brainstorming conversation with multiple AI agents, extract the key ideas, insights, and action items into concise, well-organized notes. Focus on:
      1. Main ideas discussed
      2. Key insights or breakthroughs
      3. Action items or next steps
      4. Important questions raised
      5. Different perspectives provided by the agents
      
      Format the notes as clear, bullet-pointed items that capture the essence of the brainstorming session.
      
      Conversation:
      ${conversationText}
      
      Notes:`;

      const response = await this.noteGenerationModel.call([
        new SystemMessage('You are an expert note-taker who extracts key points from multi-agent brainstorming conversations.'),
        new HumanMessage(notePrompt)
      ]);

      return response.content;
    } catch (error) {
      console.error('Error generating notes:', error);
      throw new Error('Failed to generate notes');
    }
  }

  async suggestFollowUpQuestions(userMessage, conversationHistory = []) {
    try {
      const context = conversationHistory
        .slice(-3) // Last 3 messages for context
        .map(msg => {
          if (msg.role === 'user') {
            return `User: ${msg.content}`;
          } else if (msg.agents) {
            return msg.agents.map(agent => `${agent.name}: ${agent.content}`).join('\n');
          } else {
            return `Assistant: ${msg.content}`;
          }
        })
        .join('\n');

      const prompt = `Based on this brainstorming conversation context with multiple AI agents and the user's latest message, suggest 2-3 thoughtful follow-up questions that would help deepen the exploration of their ideas.

      Context:
      ${context}
      
      Latest message: ${userMessage}
      
      Suggest questions that are:
      1. Open-ended and thought-provoking
      2. Help explore different angles or perspectives
      3. Encourage deeper thinking about the topic
      4. Consider both creative and practical aspects
      
      Format as a simple list of questions.`;

      const response = await this.noteGenerationModel.call([
        new SystemMessage('You are a brainstorming facilitator who asks insightful questions based on multi-agent conversations.'),
        new HumanMessage(prompt)
      ]);

      return response.content;
    } catch (error) {
      console.error('Error generating follow-up questions:', error);
      return null;
    }
  }

  // Method to get agent info for frontend
  getAgentInfo() {
    return Object.values(this.agents).map(agent => ({
      name: agent.name,
      emoji: agent.emoji
    }));
  }
}

module.exports = new MultiAgentService(); 
